  
  优秀的Debug能力、优秀的框架设计能力、夯实的算法基础、基本的编码素养、重视自测、别造无意义的轮子、记录卡点问题、规范命名、谨慎使用新技术、
重视warning、控制不合理需求、积极主动的精神、重视日志Log、重视计算机英语能力、做好单元测试

## 设计原则
### 1.开闭原则  
一个软件实体，如类，模块和函数应该对外扩展开发，对内修改关闭。
解读：用抽象构建框架，用实现扩展细节。不以改动原有类的方式来实现新需求，而是应该以实现事先抽象出来的接口（或具体类继承抽象类）的方式来实现。
优点：开闭原则的优点在于可以在不改动原有代码的前提下给程序扩展功能。增加了程序的可扩展性，同时也降低了程序的维护成本。
### 2.单一职责原则  
一个类只允许有一个职责，即只有一个导致该类变更的原因。
解读：类职责的变化往往就是导致类变化的原因：也就是说如果一个类具有多种职责，就会有多种导致这个类变化的原因，从而导致这个类的维护变得困难。
往往在软件开发中，随着需求的不断增加，可能会给原来的类添加一些本来不属于它的一些职责，从而违反了单一职责原则。如果我们发现当前类的职责不仅仅有一个，
就应该将本来不属于该类真正的职责分离出去。不仅仅是类，函数也要遵循单一职责原则，即一个函数制作一件事情。如果发现一个函数里面有不同的任务，则需要将不同的任务以另一个函数的形式分离出去。
优点：如果类与方法的职责划分的很清晰，不但可以提高代码的可读性，更实际性地更降低了程序出错的风险，因为清晰的代码会让bug无处藏身，也有利于bug的追踪，也就是降低了程序的维护成本。
### 3.依赖倒置原则  
依赖抽象而不是依赖实现。抽象不应该依赖细节，细节应该依赖抽象。高层模块不能依赖低层模块，二者都应该依赖抽象。
解读：针对接口编程，而不是针对实现编程。尽量不要从具体的类派生，而是以继承抽象类或实现接口来实现。关于高层模块与低层模块的划分可以按照决策能力的高低进行划分。
业务层自然就处于上层模块，逻辑层和数据层自然就归类为底层。
优点：通过抽象来搭建框架，建立类和类的关联，以减少类间的耦合性。而且以抽象搭建的系统要比以具体实现搭建的系统更加稳定，扩展性更高，同时也便于维护。
### 4.接口分离原则  
多个特定的客户端接口要好于一个通用性的总接口。
解读：客户端不应该依赖它不需要实现的接口。不建立庞大臃肿的接口，应尽量细化接口，接口中的方法应尽量少。需要注意的是接口的力度也不能太小，如果过小，则会造成接口数量过多，使设计复杂化。
优点：避免同一个接口里面包含不同类职责的方法，接口责任划分更加明确，符合高内聚低耦合的思想。
### 5.迪米特法则  
一个对象应该对尽可能少的对象有接触，也就是只接触那些真正需要接触的对象。
解读：迪米特法则也叫做最少知道原则，一个类应该只和它的成员变量，方法的输入，返回参数中的类作交流，而不应该引入其他的类（间接交流）。
优点：实践迪米特法则可以良好地降低类与类之间的耦合，减少类与类之间的关联程度，让类与类之间的协作更加直接。
### 6.里氏替换原则  
所有引用基类的地方必须能透明地使用其子类的对象，也就是说子类对象可以替换其父类对象，而程序执行效果不变。
解读：在继承体系中，子类中可以增加自己特有的方法，也可以实现父类的抽象方法，但是不能重写父类的非抽象方法，否则该继承关系就不是一个正确的继承关系。
优点：可以检验继承使用的正确性，约束继承在使用上的泛滥。

## 设计模式
### 1	创建型模式  
这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。	  
工厂模式（Factory Pattern）  
抽象工厂模式（Abstract Factory Pattern）  
单例模式（Singleton Pattern）  
建造者模式（Builder Pattern）  
原型模式（Prototype Pattern）  
### 2	结构型模式  
这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。	  
适配器模式（Adapter Pattern）  
桥接模式（Bridge Pattern）  
过滤器模式（Filter、Criteria Pattern）  
组合模式（Composite Pattern）  
装饰器模式（Decorator Pattern）  
外观模式（Facade Pattern）  
享元模式（Flyweight Pattern）  
代理模式（Proxy Pattern）  
###  3	行为型模式  
这些设计模式特别关注对象之间的通信。	  
责任链模式（Chain of Responsibility Pattern）  
命令模式（Command Pattern）  
解释器模式（Interpreter Pattern）  
迭代器模式（Iterator Pattern）  
中介者模式（Mediator Pattern）  
备忘录模式（Memento Pattern）  
观察者模式（Observer Pattern）  
状态模式（State Pattern）  
空对象模式（Null Object Pattern）  
策略模式（Strategy Pattern）  
模板模式（Template Pattern）  
访问者模式（Visitor Pattern）  